---
title: "RDA_vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{RDA_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

### Redundancy analysis (RDA)

```{r setup, warning=FALSE, message=FALSE}
# library(algatr)
library(here)
library(gt)
# RDA
library(vegan)
library(raster)
library(robust)
library(tidyverse)
# BiocManager::install("qvalue")
library(qvalue)

devtools::load_all()
```

Redundancy analysis (RDA) is a genotype-environmental association (GEA) method that uses constrained ordination to detect outlier loci that are significantly associated with environmental variables. It does so by combining regression (in which response variables are genetic data, in our case, while explanatory variables are environmental) with ordination (a PCA). Importantly, both explanatory and response variables can be multivariate, which is part of the appeal of this method. Model selection is performed by starting with a null model wherein the response is only explained by an intercept, and environmental variables are added until the amount of variance explained by a model that includes all variables is reached. By doing so, this method minimizes the *redundancy* among explanatory variables. Importantly, we can also perform an RDA that accounts for *covariables* (or "conditioning variables") such as neutral population structure. When covariables are included, this is called a **partial RDA**.

Some of the earliest uses of using RDA for identifying environment-associated loci are [Lasky et al. 2012](https://onlinelibrary.wiley.com/doi/10.1111/j.1365-294X.2012.05709.x) and [Forester et al. 2016](https://onlinelibrary.wiley.com/doi/10.1111/mec.13476). Since then, there have been several reviews and walkthroughs of the method that provide additional information, including workflows and comparisons to other GEA methods (e.g., [Forester et al. 2018](https://onlinelibrary.wiley.com/doi/full/10.1111/mec.14584)). Much of algatr's code is adapted from one such paper, [Capblancq & Forester 2021](https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13722), the code of which is available [here](https://github.com/Capblancq/RDA-landscape-genomics).

RDA cannot take in missing values. Imputation based on the per-site median is commonly performed, but there are several other ways researchers can deal with missing values. Here, we'll explore imputing on the median, but strongly urge researchers to use extreme caution when using this form of simplistic imputation. We mainly provide code to impute on the median for testing datasets and highly discourage its use in further analyses.

The general workflow to perform an RDA with algatr is as follows:

-   


### Read in and process genetic data

Running an RDA requires three data files for input: a genotype dosage matrix (the `gen` argument), a genotype dosage matrix (the `gen` argument) and the environmental values extracted at sampling coordinates (the `env` argument). Let's first convert our vcf to a dosage matrix using the `vcf_to_dosage()` function. *N.B.: our code assumes that sample IDs from our genetic data and our coords are in the same order; be sure to check this before moving forward!*

```{r gen data, warning = FALSE}
load_example()
# Convert from vcf to dosage matrix:
gen <- vcf_to_dosage(liz_vcf)
```

As mentioned above, running an RDA requires that your genotype matrix contains no missing values. Let's impute missing values based on the per-site median. *N.B.: this type of simplistic imputation is strongly not recommended for downstream analyses and is used here for example's sake!*

```{r impute}
# Are there NAs in the data?
gen[1:5, 1:5]
gen <- simple_impute(gen)
# Check that NAs are gone
gen[1:5, 1:5]
```

### Process environmental data

Let's extract environmental variables using the `extract()` function from the raster package. We also need to standardize environmental varibles. This is particularly important if we are using (for example) bioclimatic variables as input, as units of measurement are completely different (e.g., mm for precipitation vs. degrees celsius for temperature). To do so, we'll use the `scale()` function within the raster package.

```{r enviro data}
# Extract enviro vars
env <- extract(CA_env, liz_coords)

# Standardize environmental variables and make into dataframe
env <- scale(env, center = TRUE, scale = TRUE)
env <- data.frame(env)
```

## Running an RDA using `rda_run()`

------------------------------------------------------------------------

The main function within algatr to perform an RDA is `rda_run()`, which makes use of the `rda()` function within the vegan package.

### Run a simple RDA

A simple RDA is one in which our model will not account for covariables in the model. Let's first run a simple RDA on all environmental variables (i.e., no variable selection). This is specified using the `model` argument.

```{r full model, warning = FALSE, message = FALSE}
mod_full <- rda_run(gen, env, 
               model = "full", # can set to best as well
               correctGEO = FALSE,
               correctPC = FALSE,
               Pin = 0.05,
               R2permutations = 1000,
               R2scope = T)
```

```{r rsq ANOVA}
# get RSquared and run ANOVA
mod_rsq <- vegan::RsquareAdj(mod)
mod_aov <- anova(mod)
```

Now, let's run variable selection procedure by specifying the `"best"` model within `rda_run()`, which is accomplished with the `ordiR2step()` function in the vegan package. Running variable selection requires specifying several more parameters: the limits of permutation p-values for adding (`Pin`) or dropping (`Pout`) a term to the model, the number of permutations used in the estimation of adjusted R2 (`R2permutations`), and whether the use the adjusted R2 value as the stopping criterion (`R2scope`; only models with adjusted R2 values lower than specified are accepted).

```{r best model, warning = FALSE, message = FALSE}
mod_best <- rda_run(gen, env, 
               model = "best",
               correctGEO = FALSE,
               correctPC = FALSE,
               Pin = 0.05,
               R2permutations = 1000,
               R2scope = T)
```

### Run a partial RDA

A partial RDA, as described at the beginning of the vignette, is when covariables (or conditioning variables) are incorporated into the RDA. Within `rda_run()`, users have the option of including sampling coordinates (`correctGEO`; if this is set to true, then `coords` must also be provided) or selecting PC axes (`correctPC`; if this is set to `TRUE`, then `nPC` must also be provided) as conditioning variables. For `nPC`, we can also set this argument to `"manual"`, in which case a screeplot will be generated and a user can manually enter the number of PCs to include into the console.

```{r partial rda}
mod <- rda_run(gen, env, liz_coords,
               model = "best",
               correctGEO = TRUE,
               correctPC = TRUE,
               nPC = 3,
               Pin = 0.05,
               R2permutations = 1000,
               R2scope = T)
```

### Identifying candidate SNPs with `rda_getoutliers()`

Now that we have the models run, we can discover SNPs that are candidate outliers. In algatr, this can be done using two different methods to detect outlier loci, specified by the `outlier_method` argument. The first, using p-values, is described in [Capblancq and Forester 2021](https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13722); their code can be found [here](https://github.com/Capblancq/RDA-landscape-genomics). The other method, relying on z-scores for outlier detection, is from [Forester et al. 2018](https://onlinelibrary.wiley.com/doi/abs/10.1111/mec.14584); their code can be found [here](https://popgen.nescent.org/2018-03-27_RDA_GEA.html).

Let's start with using the p-value method to detect outlier loci:

```{r cand snps}
# Running with all axes
rda_sig <- rda_getoutliers(mod, naxes = naxes, outlier_method = "p", padj_method = "fdr", sig = 0.05)

# Get SNPs
rda_snps <- rda_sig$rda_snps
```

Now, let's try the z-score method to detect oulier loci:

How do the results compare?


## Interpreting RDA results

------------------------------------------------------------------------


## Visualizing RDA results

------------------------------------------------------------------------

## Look at simple RDA results

The results from `rda_do_everything()` contain:

-   Candidate SNPs: `rda_snps`

-   Data frame of environmental associations with outlier SNPs: `cor_df`

-   RDA model specifics: `rda_mod`

-   Outlier test results: `rda_outlier_test`

-   Relevant R-squared values: `rsq`

-   ANOVA results: `anova`

-   List of all p-values: `pvalues`

In our case, we can see that there were 138 outlier SNPs detected.

```{r simple results}
summary(results)
```

### Visualize results using `rda_plot()`

## Biplot

Let's build a biplot with RDA axes 1 and 2. The default of `rda_plot()` is to plot all variables.

```{r biplot simple}
rda_plot(results$rda_mod, results$rda_snps, biplot_axes = c(1,2), rdaplot = TRUE, manhattan = FALSE)
```

## Manhattan plot

Let's now build a Manhattan plot with a significance level of 0.05.

```{r Manhattan simple}
rda_plot(results$rda_mod, results$rda_snps, results$pvalues, sig = 0.05, manhattan = TRUE, rdaplot = FALSE)
```

### Run a partial RDA

A partial RDA describes incorporating covariables into a redundancy analysis. For more information, there is an excellent description of the difference between a simple and partial RDA in [Capblancq and Forester 2021](https://besjournals.onlinelibrary.wiley.com/doi/10.1111/2041-210X.13722). Built within the `rda_do_everything()` function is the option to account for geographic distance and XXX as possible covariables (or the combination of the two).

To condition on geographic sampling coordinates, use the `correctGEO` argument:



Let's look at how these results compare.

```{r}
# TODO [EAC] fill in 
```

## Variable selection

```{r, warning = TRUE, message = FALSE}
results <- rda_do_everything(gen, 
                            env, 
                            coords, 
                            model = "best",
                            correctGEO = FALSE, 
                            correctPC = FALSE,
                            sig = 0.05, 
                            padj_method = "fdr")
```

## Separate functions

### 1. Prepare data
```{r}
# Extract and standardize environmental variables
env <- raster::extract(CA_env, coords)
env <- scale(env, center = TRUE, scale = TRUE) 
env <- data.frame(env)
    
# Remove any NA values
if(any(is.na(env))){
  warning("NA values found in env data, removing rows with NAs for RDA")
  gen <- gen[complete.cases(env),]
  coords <- coords[complete.cases(env),]
  env <- env[complete.cases(env),]
}
if(any(is.na(gen))){
  warning("NA values found in gen data, removing rows with NAs for RDA")
  env <- env[complete.cases(gen),]
  coords <- coords[complete.cases(gen),]
  gen <- gen[complete.cases(gen),]
}
```

### 2. Run RDA
```{r}
mod <- rda_run(gen, env, correctGEO = FALSE, correctPC = FALSE)
```


### 3. Identify candidate snps
```{r}

# Running with all axes and z method
rda_sig <- rda_getoutliers(mod, naxes = "all", outlier_method = "z", z = 3)
rda_snps <- rda_sig[["rda_snps"]]
length(rda_snps)

# Running with all axes and p method
rda_sig <- rda_getoutliers(mod, naxes = "all", outlier_method = "p", padj_method = "fdr", sig = 0.01)
rda_snps <- rda_sig[["rda_snps"]]
pvalues <- rda_sig[["pvalues"]]
length(rda_snps)

```

### 4. Identify environmental associations
```{r}
rda_gen <- gen[,rda_snps]
cor_df <- rda_cor(rda_gen, env)

# You can make a pretty table from these results (here we are displaying only the first 5 rows):
rda_table(cor_df, nrow = 5)

# you can order by the strength of the correlation
rda_table(cor_df, order = TRUE, nrow = 5)

# you can choose to only keep the top variable for each SNP the table by the strength of the correlation
rda_table(cor_df, top = TRUE, nrow = 5)

# you can display only select environmental variables
rda_table(cor_df, var = "CA_rPCA1", nrow = 5)

# putting it all together we can display the top 5, ordered SNPS for each variable
rda_table(cor_df, top = TRUE, order = TRUE, var = "CA_rPCA1", nrow = 5)
rda_table(cor_df, top = TRUE, order = TRUE, var = "CA_rPCA2", nrow = 5)
rda_table(cor_df, top = TRUE, order = TRUE, var = "CA_rPCA3", nrow = 5)
```

### 5. Plot results

```{r, fig.width = 6, fig.height = 5}
rda_plot(mod, rda_snps, biplot_axes = c(1,3), rdaplot = TRUE)
rda_plot(mod, rda_snps, biplot_axes = c(2,3), rdaplot = TRUE)
rda_plot(mod, rda_snps, pvalues, sig = 0.05, manhattan = TRUE, rdaplot = FALSE)

# note: if only one axis is provided, a histogram will be generated
rda_plot(mod, rda_snps, axes = 1, rdaplot = TRUE, binwidth = 0.01)
```

## Running RDA with `rda_do_everything()`

------------------------------------------------------------------------

The algatr package also has an option to run all of the above functionality in a single function, `rda_do_everything()`. This function will TODO XXXXX. The resulting object looks identical to the output object from TODO XXXX.

```{r do everything}
results <- rda_do_everything(gen, CA_env, liz_coords, 
                            correctGEO = FALSE, 
                            correctPC = FALSE,
                            outlier_method = "p",
                            sig = 0.05, 
                            padj_method = "fdr")
```

Now, let's run the same analysis but instead using the z-scores method to detect outlier loci:

```{r}
results <- rda_do_everything(gen, env, coords, 
                            correctGEO = FALSE, 
                            correctPC = FALSE,
                            outlier_method = "z",
                            z = 3, 
                            padj_method = "fdr")
```

### Partial RDA

```{r, warning = TRUE, message = FALSE}
results <- rda_do_everything(gen, 
                            env, 
                            coords, 
                            model = "full",
                            correctGEO = TRUE, 
                            correctPC = FALSE,
                            sig = 0.05, 
                            padj_method = "fdr")
```

To condition on PCs built using a PCA of all genotypes, use the `correctPC` argument:

```{r, warning = TRUE, message = FALSE}
results <- rda_do_everything(gen, 
                            env, 
                            coords, 
                            model = "full",
                            correctGEO = FALSE, 
                            correctPC = TRUE,
                            sig = 0.05, 
                            padj_method = "fdr")
```

To condition both on PCs and geographic coordinates:

```{r, warning = TRUE, message = FALSE}
results <- rda_do_everything(gen, 
                            env, 
                            coords, 
                            model = "full",
                            correctGEO = TRUE, 
                            correctPC = TRUE,
                            sig = 0.05, 
                            padj_method = "fdr")
```
