---
title: "MMRR_vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MMRR_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Multiple matrix regression with randomization (MMRR)

```{r setup, warning = FALSE, message = FALSE}
library(algatr)
library(here)
```

Multiple matrix regression with randomization ([Wang 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/evo.12134)) examines how heterogeneity in the landscape (both geographic and environmental) affects spatial genetic variation, allowing a user to determine the relative contributions of isolation by distance (i.e., an association between genetic and geographic distances) and isolation by environment (i.e., an association between genetic and environmental distances). MMRR can provide information concerning how dependent variables (in our case, genetic data) change with respect to multiple independent variables (environmental and geographic distances).

The randomization aspect of MMRR is that significance testing is performed through random permutations of the rows and columns of the dependent matrix (the genetic distances), which is necessary because of the non-independence of values in pairwise distance matrices. Once significance testing is completed, MMRR provides individual regression coefficients and p-values for each dependent variable and a "coefficient ratio," which is the ratio between regression coefficients, which thus provides an idea of the relative contributions of IBD and IBE in explaining variation in the genetic distances in your data.

There is one main function to perform an MMRR analysis: `mmrr_do_everything()`. This function runs MMRR and allows a user to run MMRR with all variables or with backward elimination variable selection to choose the best-supported variables. This function outputs information on the final model and coefficients for the explanatory variables.

There are a few assumptions built into this function that users should be aware of: (1) the coords and gendist files MUST have the same ordering of individuals; there isn't a check for this, and (2) this function assumes individual-based sampling and that each individual is a sampling site with individual coordinates.

## Read in and process data files

Running MMRR_do_everything() requires three data files for input: a genetic distance matrix (the `gendist` argument), coordinates for samples (the `coords` argument), and environmental layers on which the coordinates are found (the `envlayers` argument).
[# Need to be careful of the wording here, because this isn't true for MMRR, sensu strictu; this is true for mmmrr_do_everything.]

```{r data}
# Load vcf, coords, and CA enviro layers
load_example()
```

## Run MMRR

### MMRR with all variables

```{r all vars, fig.width = 5, fig.height = 5}
set.seed(01)
mmrr_all <- mmrr_do_everything(gendist, liz_coords, envlayers = CA_env, model = "full")

```

## MMRR with model selection

```{r best vars, fig.width = 5, fig.height = 5}
set.seed(10)
mmrr_best <- mmrr_do_everything(gendist, liz_coords, envlayers = CA_env, model = "best", nperm = 100)
```

## Step by Step

Create distance matrix:

```{r, fig.width = 5, fig.height = 5}
# Make an dataframe with environmental data
env <- raster::extract(CA_env, liz_coords)
X <- env_dist(env)

# Add geographic distance
X[["geodist"]] <- geo_dist(liz_coords)

# Make a genetic distance matrix
Y <- as.matrix(gendist)

# Run MMRR with variable selection
set.seed(10)
results <- mmrr_best(Y, X, nperm = 99, stdz = TRUE, plot = TRUE)

# Run MMRR with all variables
set.seed(01)
results <- mmrr_full(Y, X, nperm = 99, stdz = TRUE, plot = TRUE)
```

You can also produce each plot separately:

```{r, fig.width = 5, fig.height = 5}
# Covariance plot
mmrr_plot(X = X, plot_type = "cov", stdz = TRUE)

# Single variable plot
mmrr_plot(Y, X, plot_type = "vars", stdz = TRUE)

# Fitted variable plot
# TODO [EAC]: needs to be fixed
mmrr_plot(Y, X, mod = results$mod, plot_type = "fitted", stdz = TRUE)
```

Now, let's take a look at the output statistics:

```{r stats}
# TODO [EAC]: should this be built in within the function?
```

## Running MMRR with `mmrr_do_everything()`

------------------------------------------------------------------------

The algatr package also has an option to run all of the above functionality in a single function, `mmrr_do_everything()`. This function will TODO XXXXX. The resulting object looks identical to the output object from TODO XXXX.

```{r do everything}

```
