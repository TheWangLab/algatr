---
title: "MMRR_vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{MMRR_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Multiple matrix regression with randomization (MMRR)

```{r setup, warning = FALSE, message = FALSE}
library(algatr)
library(here)
```

Multiple matrix regression with randomization ([Wang 2013](https://onlinelibrary.wiley.com/doi/full/10.1111/evo.12134)) examines how heterogeneity in the landscape (both geographic and environmental) affects spatial genetic variation, allowing a user to disentangle isolation by distance (i.e., an association between genetic and geographic distances) from isolation by environment (i.e., an association between genetic and environmental distances). MMRR can provide information concerning how dependent variables (in our case, genetic data) change with respect to multiple independent variables (environment and geographic distances).

The randomization aspect of MRR is that significance testing is achieved through random permutations of the rows and columns of the dependent matrix (i.e., genetic distances), and provides significance values for each variable. Once significance testing is completed, MMRR provides a "coefficient ratio", which is the ratio between regression coefficients and thus provides an idea of the relative contributions of IBD and IBE on the genetic variation of your data.

There is one main function to perform a MMRR: `mmrr_do_everything()`. This function runs MMRR, and allows a user to run MMRR with all variables, or with model selection to choose the best-supported variables. This function outputs information on the final model, and coefficients for predictor variables.

### Read in and process data files

Running MMRR requires three data files for input: a genetic distance matrix (the `gendist` argument), coordinates for samples (the `coords` argument), and environmental layers on which to run the GDM (the `envlayers` argument).

```{r data}
# Load vcf, coords, and CA enviro layers
load_example()
```

## Run MMRR

### MMRR with all variables

```{r all vars, fig.width = 5, fig.height = 5}
set.seed(01)
mmrr_all <- mmrr_do_everything(gendist, liz_coords, envlayers = CA_env, model = "full")
```

<<<<<<< HEAD
### MMRR with model selection

```{r best vars}
mmrr_best <- mmrr_do_everything(gendist, liz_coords, envlayers = CA_env, model = "best", n_perm = 100)
```

## MMRR results

```{r results}
results <- mmrr_var_sel()
```
=======
## MMRR with model selection
```{r best vars, fig.width = 5, fig.height = 5}
set.seed(10)
mmrr_best <- mmrr_do_everything(gendist, liz_coords, envlayers = CA_env, model = "best", nperm = 100)
```
# Step by Step

Create distance matrix:

```{r, fig.width = 5, fig.height = 5}
# Make an dataframe with environmental data
env <- raster::extract(CA_env, liz_coords)
X <- env_dist(env)

# Add geographic distance
X[["geodist"]] <- geo_dist(coords)

# Make a genetic distance matrix
Y <- as.matrix(gendist)

# Run MMRR with variable selection
set.seed(10)
results <- mmrr_best(Y, X, nperm = 99, stdz = TRUE, plot = TRUE)

# Run MMRR with all variables
set.seed(01)
results <- mmrr_full(Y, X, nperm = 99, stdz = TRUE, plot = TRUE)
```

You can also produce each plot separately:

```{r, fig.width = 5, fig.height = 5}
# Covariance plot
mmrr_plot(X = X, plot_type = "cov", stdz = TRUE)

# Single variable plot
mmrr_plot(Y, X, plot_type = "vars", stdz = TRUE)

# Fitted variable plot
mmrr_plot(Y, X, mod = results$mod, plot_type = "fitted", stdz = TRUE)
```

>>>>>>> main
