---
title: "Environmental_data_vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Environmental_data_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Processing environmental data

```{r setup, warning = FALSE, message = FALSE}
library(algatr)
library(terra)
library(raster)
library(geodata)
library(here)
library(viridis)
```

For landscape genomic analyses, environmental data layers must be processed in several ways before they can be used as input into methods. This vignette will explore several ways to process environmental data:

-   `get_worldclim()` to pull environmental layers remotely from the WorldClim database

-   `TODO` to detect collinearity between environmental layers

-   `TODO` to perform a raster PCA on a stack of environmental layers to reduce dimensionality

-   `coords_to_raster()` to create a raster layer from coordinate data

-   `env_dist()` to calculate environmental distances

-   `geo_dist()` to calculate geographic distances between coordinates

### Load example data

```{r test data}
load_example()
```

### Introduction to environmental data files and object types

Briefly, in R, any (geo)spatial data can be represented using vectors or rasters. Vectors are used for discrete phenomena that have clear boundaries (e.g., a country), while rasters are used to represent continuous data (e.g., precipitation). Rasters are able to represent continuous data by dividing up the landscape into a grid of equally sized cells; each cell is then assigned one (or more) values for relevant variables. In our case, taking California as an example, vectors are used to represent data points (e.g., sampling coordinates) or polygons (e.g., the state of California); rasters are used for storing environmental attributes of California.

There are two main packages algatr uses to process and manipulate environmental data: terra ([Hijmans 2022](https://cran.r-project.org/web/packages/terra/index.html)) and raster ([Hijmans 2022](https://cran.r-project.org/web/packages/raster/index.html)). Both of these packages have excellent resources and walkthroughs (see [here](https://rspatial.org/terra/) for terra; see [here](https://rspatial.org/raster/pkg/index.html) for raster) that explain in depth environmental data processing and manipulation in R.

Each of these packages has their own classes to represent rasters. Within the terra package, the `SpatRaster` class is used to represent rasters, while the raster package uses `RasterLayer` (single-layer raster data), `RasterBrick` and `RasterStack` (both are multi-variable raster data but differ in how many files can be linked to them) classes. No matter which class is used to represent rasters, the fundamental parameters that describe these rasters is always the same: numbers of rows, columns, the spatial extent, and the coordinate reference system (CRS) for proper projection.


### Gather environmental data using `get_worldclim()`

------------------------------------------------------------------------

WorldClim is a database that provides environmental layers for the entire globe (excluding Antarctica); the data contained are four monthly variables and 18 bioclimatic variables, which are provided in tiles. The `get_worldclim()` function retrieves and extracts WorldClim data (using the `worldclim_tile()` function in the geodata package) from relevant tiles based on your sampling coordinates, drawing a convex hull shape to connect all data points.

Users can add a buffer around sampling coordinates using the `buff` argument, which corresponds to the proportion of the spatial extent for the coordinates. Tile size (i.e., spatial resolution) is specified using the `res` argument, which corresponds to arc-minutes. The default is the 30s dataset (0.5 arc-mins), with a buffer of 0.01.

```{r get worldclim}
wclim <- get_worldclim(coords = liz_coords) # can set save_output = TRUE if you want a directory with files made
```

Notice that `wclim` is a terra `SpatRaster` object. Let's take a look at what this object looks like.

```{r wclim}
# See how many layers are contained within the object
nlyr(wclim)

# Look at one of the layers, which corresponds to tile_15_wc2.1_30s_bio_1
wclim[[1]]
```

Now, let's plot one of the variables and overlay our sampling coordinates on top.

```{r wclim plot, warning = FALSE}
terra::plot(wclim[[1]], col = turbo(100), axes = FALSE)
points(liz_coords, pch = 19)
```


### Detect collinearity among environmental layers with `TODO`

------------------------------------------------------------------------

### Perform a raster PCA on environmental layers with `TODO`

------------------------------------------------------------------------

Because of collinearity issues, and because we may not want to deal with dozens of environmental layers at a time, we can perform a PCA on our rasters using the `XXX` function.

Now, let's plot the resulting environmental PCs to see how they look.

```{r data}
# Gather the files corresponding to the three PCs
env_files <- list.files(here("inst", "extdata", "PC_layers"), full.names = TRUE)
# Stack into a spatial raster object
envstack <- terra::rast(env_files)
```

Take a look at the rasters:

```{r plot rasters, warning = FALSE, message = FALSE, fig.width = 5, fig.height = 5}
terra::plot(envstack, col = turbo(100), axes = FALSE)
```

We can combine all three PCs into a single map by scaling each of the rasters in such a way that they each correspond to either R, G, or B.

```{r, RGB plot, fig.width = 5, fig.height = 6}
for(layer in 1:3){
  minval <- minmax(envstack[[layer]])[1,]
  maxval <- minmax(envstack[[layer]])[2,]
  
  envstack[[layer]] <- ((envstack[[layer]] - minval) / (maxval - minval))*255
}

terra::plotRGB(envstack, r = 1, g = 2, b = 3)
```

Within the example dataset, the object `CA_env` is a PCA raster stack.


### Create raster from coordinates with `coords_to_raster()`

------------------------------------------------------------------------

In some cases, we may not have a raster already prepared. We can use our coordinate data to generate a raster given a user-specified buffer around sampling coordinates (using the `buff` argument) and with a given resolution (using the `res` argument).

```{r coords to raster}

```

### Calculate environmental distances using `env_dist()`

------------------------------------------------------------------------

### Calculate geographic distances using `geo_dist()`

------------------------------------------------------------------------
(1) Import environmental layers
(2) Calculate environmental distance



